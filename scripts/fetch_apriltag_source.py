#!/usr/bin/env python3
"""Fetch and parse AprilTag source files to extract code data and bit ordering.

Usage:
    python scripts/fetch_apriltag_source.py
"""

import re
import sys


def parse_codes(content):
    # Match: static uint64_t codedata[2115] = { ... };
    match = re.search(r"static uint64_t codedata\[\d+\] = \{(.*?)\};", content, re.DOTALL)
    if not match:
        print("Error: Could not find codedata array")
        return []

    hex_codes = re.findall(r"0x[0-9a-fA-F]+", match.group(1))
    return [int(c, 16) for c in hex_codes]


def parse_bit_order(content):
    bit_x = {}
    bit_y = {}

    # Match: tf->bit_x[1] = -1;
    for match in re.finditer(r"tf->bit_x\[(\d+)\] = (-?\d+);", content):
        bit_x[int(match.group(1))] = int(match.group(2))

    for match in re.finditer(r"tf->bit_y\[(\d+)\] = (-?\d+);", content):
        bit_y[int(match.group(1))] = int(match.group(2))

    if not bit_x:
        print("Warning: explicit bit_x/y assignments not found.")
        return None

    ordered = []
    max_idx = max(bit_x.keys())
    for i in range(max_idx + 1):
        if i in bit_x:
            ordered.append((bit_x[i], bit_y[i]))
        else:
            print(f"Warning: missing bit index {i}")
            ordered.append((0, 0))  # Placeholder

    return ordered


def parse_total_width(content):
    match = re.search(r"tf->total_width = (\d+);", content)
    if match:
        return int(match.group(1))
    return 9  # Default for 41h12


def main():
    try:
        with open("scripts/tagStandard41h12.c", "r") as f:
            content = f.read()
    except FileNotFoundError:
        print("Error: scripts/tagStandard41h12.c not found. Run curl first.")
        return

    codes = parse_codes(content)
    print(f"Parsed {len(codes)} codes.")

    bit_order = parse_bit_order(content)
    # total_width = parse_total_width(content)
    # Actually, let's hardcode width logic in generator or output it here

    if bit_order:
        print(f"Parsed bit order with {len(bit_order)} points.")
    else:
        print("Could not parse bit order.")

    # Output to a file that can be imported
    with open("scripts/apriltag_41h12_data.py", "w") as f:
        f.write("# Generated by scripts/fetch_apriltag_source.py\n")
        f.write("# Source: tagStandard41h12.c\n\n")

        f.write(f"APRILTAG_41H12_CODES_SPIRAL = [\n")
        for i in range(0, len(codes), 4):
            chunk = codes[i : i + 4]
            hex_strs = [f"0x{c:016x}" for c in chunk]
            f.write(f"    {', '.join(hex_strs)},\n")
        f.write("]\n\n")

        if bit_order:
            f.write("UMICH_41H12_BIT_ORDER = [\n")
            for x, y in bit_order:
                f.write(f"    ({x}, {y}),\n")
            f.write("]\n")
        else:
            f.write("UMICH_41H12_BIT_ORDER = []\n")


if __name__ == "__main__":
    main()
