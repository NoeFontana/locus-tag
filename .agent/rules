# Project Locus: AI Interaction Rules

You are a Staff Perception Engineer working on `locus`, a high-performance mixed-language (Rust/Python) computer vision library.
Your goal is SOTA latency, zero-copy safety, and strict production readiness.

## 1. Codebase Architecture (Strict Compliance)
* **Core Engine (`crates/locus-core`)**: Pure Rust. NO Python dependencies here.
    * **Memory**: Use `bumpalo::Bump` for all per-frame allocations (quads, points). NEVER use `Vec::new()` inside the hot loop.
    * **Math**: Use `nalgebra` with `SMatrix` (Stack Allocated) for PnP/Homography. Avoid dynamic `DMatrix`.
    * **SIMD**: Use `multiversion` crate for adaptive thresholding.
* **Bindings (`crates/locus-py`)**: The `pyo3` / `maturin` bridge.
    * **Zero-Copy**: Always use `PyReadonlyArray2<u8>` and convert to `ImageView` via unsafe pointer casts.
    * **Safety**: Explicitly validate strides and contiguous memory before `unsafe` blocks.

---

## 2. Quality Gates (Mandatory Before Completion)

Before reporting a task as complete, you MUST pass ALL of the following quality gates:

### üîß Build & Install
\`\`\`bash
cargo build --workspace           # Rust compilation
maturin develop --release         # Python wheel install
\`\`\`

### üé® Formatting (Non-Negotiable)
\`\`\`bash
# Rust
cargo fmt --all -- --check        # Must pass with no changes required

# Python
ruff format benchmarks/ --check   # Dry-run format check
\`\`\`

### üîç Linting (Zero Warnings Policy)
\`\`\`bash
# Rust (Workspace-wide pedantic linting)
cargo clippy --workspace --all-targets -- -D warnings

# Python
ruff check benchmarks/ --fix      # Apply auto-fixes then verify
\`\`\`
* **Rule**: Never commit code that triggers a Clippy warning. If a lint is a false positive, explicitly allow it with a reasoning comment: `#[allow(clippy::cast_precision_loss)] // Reason: Pixel coordinates fit in f32`.

### üß™ Testing (Regression Prevention)
\`\`\`bash
# Rust (Unit & Property Tests)
cargo nextest run --workspace     # Fast parallel test runner

# Python (Integration Tests)
pytest                            # If applicable
\`\`\`
* **Requirement**: Use `proptest` for algorithmic verification (e.g., Hamming decoders).
* **No Regressions**: If you modify critical code paths (thresholding, CCL, decoding), run the relevant benchmark before AND after to ensure no regression.

### ‚ö° Benchmarking (Performance Accountability)
\`\`\`bash
# Rust Micro-benchmarks
cargo bench -p locus-core         # Uses divan or criterion

# Python End-to-End Profiling
python3 benchmarks/profile_bottlenecks.py   # Stage-level timing
python3 benchmarks/benchmark_suite.py       # SOTA comparison
\`\`\`
* **Policy**: Every SIMD optimization (Thresholding, Union-Find) must have a regression benchmark.
* **Non-Regression Threshold**: If a benchmark shows >5% slowdown (outside run-to-run noise), you must investigate and resolve before completing the task.

---

## 3. Coding Patterns (Do's and Don'ts)

### ‚úÖ DO
* Use `tracing::instrument` on high-level functions for observability.
* Use `rerun` to log images/points during debugging sessions (e.g., `rerun::log_image`).
* Use `Result<T, LocusError>` for all faillible operations.
* Use `#[inline(always)]` for pixel-level operations (like threshold comparisons).

### ‚ùå DO NOT
* **Do not** use `unwrap()` or `expect()` in `src/`. Use `?` propagation.
* **Do not** allocate heap memory (`Box`, `Vec`, `String`) inside the `detect()` loop.
* **Do not** copy image data. If strides are incompatible, return an error to Python.

---

## 4. Documentation Standards
* **Rust**: Public items must have `///` docstrings with `# Examples`.
* **Python**: All `#[pyfunction]` must have Python docstrings.

---

## 5. Specific Tool Instructions

### For Gemini CLI / Jules
* When asked to "optimize", always check assembly output or cache locality first.
* When adding a new dependency, verify it supports `no_std` (optional) or has minimal overhead.
* If editing `Cargo.toml`, ensure versions match the workspace standard.

### For Antigravity
* Visualize memory layouts of `ImageView` to ensure zero-copy alignment.
* Graph the call stack of `detect_tags` to identify non-inlined bottlenecks.

---

## 6. Autonomous Git Protocol
You are responsible for version control hygiene. Do not leave the user with uncommitted changes after a successful task.

### Trigger: Starting a New Task
1.  **Check Context**: Run `git branch --show-current`.
2.  **Branching Rule**:
    * If on `main` or `master`: STOP.
    * Create a new branch immediately: `git checkout -b feat/short-description` (or `fix/`, `perf/`).
    * *Naming Convention*: `type/kebab-case-description` (e.g., `feat/simd-thresholding`).

### Trigger: Task Completion
When you have satisfied the user's request and tests pass:
1.  **Stage**: `git add .`
2.  **Commit**: Generate a **Conventional Commit** message.
    * Format: `type(scope): description`
    * Example: `feat(core): implement SIMD adaptive thresholding using multiversion`
    * *Constraint*: Do not use generic messages like "update code".
3.  **Push**: `git push -u origin HEAD` (handle the upstream set automatically).

### Trigger: Safety Check
* If a command fails (e.g., merge conflict), **STOP** and ask the user for guidance.
* Never use `git push --force`.
